# Single Linked List Class

## 1. Создание классов Node и LinkedList:

        class Node:
            def __init__(self, data) -> None:
                self.data = data
                self.next = None

        class LinkedList:
            def __init__(self) -> None:
                self.head = None

Мы создаем класс с именем `Node`. В конструкторе этого класса мы указываем аргумент `self` и `data`.
Каждый узел будет состоять из `data` и `next`. Определяем `self.data` равное тому `data`, что 
передается в конструктор объекта класса `Node`.  Мы устанавливаем `self.next` равнoе `None`.

Мы определяем `LinkedList` класс, а в конструкторе снова передаем `self`. Мы определяем `head` указатель, 
который будет указывать на первый узел в связанном списке. Изначально мы просто установили его равным `None`.

## 2. Добавление элемента в конец списка:

### 2.1. Случай с пустым связанным списком:

        def append(self, data):
            new_node = Node(data)
            if self.head == None:
                self.head = new_node
                return

Мы определяем `new_node`, используя наш класс `Node`. Он состоит из поля 'data' и 'next'. 
Что касается метода `append`, нам также необходимо учитывать случай, если связанный список пуст.
В приведенном выше коде мы проверяем, пуст ли связанный список, проверяя заголовок связанного списка.
Если `self.head` является `None`, это означает, что это пустой связанный список и в нем ничего нет. 
Указатель головы вообще ни на что не указывает, поэтому в связанном списке нет узла. Если в связанном 
списке нет узла, мы устанавливаем указатель заголовка на `new_node`, который мы создали.

### 2.2. Случай непустого связанного списка:

            last_node = self.head           
            while last_node.next:
                last_node = last_node.next
            last_node.next = new_node

Посмотрим, что мы можем сделать, если связанный список не пустой. У нас есть `new_node`, который мы 
создали, и мы хотим добавить его в связанный список. Мы можем начать с указателя головы, а затем 
двигаться по каждому из узлов в связанном списке, пока не дойдем до конца, то есть `None`.
Мы определяем, `last_node`, который изначально равен голове. Это означает, что мы находимся в начале 
связанного списка. Мы назвали переменную `last_node`, потому что она в конечном итоге будет указывать на
последний элемент. Она будет начинаться с начала связанного списка и перемещаться по связному списку до 
тех пор, пока `last_node.next` не будет указывать на `None`. Мы продолжаем двигаться от узла к узлу, 
пока не дойдем до `last_node`, где `last_node.next` укажет на `None` и не завершит цикл. После завершения 
`while` цикла `last_node` указывает на последний узел. Далее мы вводим наш `new_node` в связанный список, 
устанавливая `next` для `last_node` на `new_node`, который есть свой `next` указатель равный `None`.

Теперь нам нужен какой-то способ проверить наш `append` метод, где мы можем распечатать узлы связанного 
списка. Для этого создадим метод с именем `print_list()`.

## print_list()

Теперь нам нужен какой-то способ проверить наш `append` метод, где мы можем распечатать узлы связанного списка. Для этого создадим метод с именем `print_list()`.

        def print_list(self):
            cur_node = self.head
            while cur_node:
                print(cur_node.data)
                cur_node = cur_node.next

`print_list` - это метод класса, поэтому он будет принимать `self` в качестве аргумента и распечатывать 
записи связанного списка. Мы начнем с указателя заголовка и распечатаем компонент данных узла, а затем 
перейдем к следующему узлу. Мы проверим следующий узел, чтобы убедиться, что это не `None`. Если это не 
так, мы переходим к следующему узлу. Таким образом, мы продолжаем распечатывать данные до тех пор, пока 
не дойдем до завершающего нулем компонента связанного списка.
Мы инициализируем `cur_node` равным голове связанного списка. Затем мы используем `while` цикл, который 
продолжает работать и печатать данные, если `cur_node` не равен `None`.



